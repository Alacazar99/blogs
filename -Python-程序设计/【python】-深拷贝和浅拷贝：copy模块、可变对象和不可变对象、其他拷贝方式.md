
Python赋值操作或函数参数传递**传递的永远是对象引用**（即内存地址），而不是对象内容。在**Python中一切皆对象**，对象又分为**可变(mutable)**和**不可变(immutable)**两种类型。

 对象拷贝是指在内存中创建新的对象，产生新的内存地址。当顶层对象和它的子元素对象全都是immutable不可变对象时，不存在被拷贝，因为没有产生新对象。

- **浅拷贝(Shallow Copy)**：拷贝顶层对象，但不会拷贝内部的子元素对象。
- **深拷贝(Deep Copy)**：递归拷贝顶层对象，以及它内部的子元素对象

---
##### 可变对象和不可变对象

对象的类型决定了它装着的数据是**允许被修改的变量（可变的mutable）还是不可被修改的常量（不可变的immutable）**。你可以把不可变对象想象成一个透明但封闭的盒子：你可以看到里面装的数据，但是无法改变它。类似地，可变对象就像一个开着口的盒子，你不仅可以看到里面的数据，还可以拿出来修改它，但你无法改变这个盒子本身，即你无法改变对象的类型。


**mutable**: 可变对象，如List、Dict

**immutable**: 不可变对象，如Number、String、Tuple、Frozenset

【注释】：**Python赋值操作或函数参数传递，传递的永远是对象引用（即内存地址），而不是对象内容**。

---
#####关于 copy模块

*对象拷贝：*
是指在内存中创建新的对象，产生新的内存地址。

【特点如下】：
（1）浅拷贝只拷贝**最外层对象**，深拷贝还会**递归拷贝内层对象**；

（2）无论是浅拷贝还是深拷贝，只拷贝mutable可变对象成为一个新对象，而immutable不可变对象还是原来的那个；

（3）当顶层对象和它的子元素对象全都是immutable不可变对象时，因为没有产生新对象，所以不存在被拷贝；

---

##### 关于浅拷贝

【一句话介绍】浅拷贝(Shallow Copy)，拷贝顶层对象，但不会拷贝内部的子元素对象。

【换句话说】**传递的是地址**，不会新建一个对象。


分别讨论以下情况：

- （1）当顶层对象是mutable可变对象，但是它的子元素对象全都是immutable不可变对象

程序环境基于【jupyter-notebook】
```
In [1]: a = [1, 'world', 2]

In [2]: [ id(item) for item in a ]
Out[2]: [9164864, 140104749066928, 9164896]

In [3]: id(a)
Out[3]: 140104759916040
```
【小提升】：**导入copy模块，使用copy.copy()函数浅拷贝a，并赋值给变量b。**
```
In [4]: import copy

In [5]: b = copy.copy(a)

In [6]: b
Out[6]: [1, 'world', 2]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 140104749066928, 9164896]

In [8]: id(b)
Out[8]: 140104760027784
```

---

- （2）当顶层对象是mutable可变对象，但子元素也存在mutable可变对象（子元素部分immutable）

【举个栗子】：
```
In [1]: a = [1, 2, ['hello','world']]

In [2]: import copy

In [3]: b = copy.copy(a)

In [4]: id(a)
Out[4]: 139770596269064

In [5]: id(b)
Out[5]: 139770596639368

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 9164896, 139770596304840]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 9164896, 139770596304840]

In [8]: [ id(item) for item in a[2] ]
Out[8]: [139770585378520, 139770585378408]

In [9]: [ id(item) for item in b[2] ]
Out[9]: [139770585378520, 139770585378408]
```
【解释】：浅拷贝copy.copy()只拷贝了顶层对象，没有拷贝子元素对象['hello','world']，即a[2]和b[2]指向同一个列表对象

---

- （3）当顶层对象是immutable不可变对象，同时它的子元素对象也全都是immutable不可变对象

```
In [1]: a = (1, 2, 3)

In [2]: import copy

In [3]: b =  copy.copy(a)

In [4]: id(a)
Out[4]: 139664680010016

In [5]: id(b)
Out[5]: 139664680010016

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 9164896, 9164928]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 9164896, 9164928]
```
【解释】：变量a与变量b指向的是同一个元组对象，没有拷贝

---

- （4）当顶层对象是immutable不可变对象时，但子元素存在mutable可变对象（子元素部分mutable）
来个栗子；
```
In [1]: a = (1, 2, ['hello','world'])

In [2]: import copy

In [3]: b = copy.copy(a)

In [4]: id(a)
Out[4]: 139650704096640

In [5]: id(b)
Out[5]: 139650704096640

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 9164896, 139650704068680]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 9164896, 139650704068680]

In [8]: [ id(item) for item in a[2] ]
Out[8]: [139650692293328, 139650692293216]

In [9]: [ id(item) for item in b[2] ]
Out[9]: [139650692293328, 139650692293216]

In [10]: a[2][1] = 'china'

In [11]: a
Out[11]: (1, 2, ['hello', 'china'])

In [12]: b
Out[12]: (1, 2, ['hello', 'china'])
```
【解释一下】：变量a与变量b指向的是相同的元组对象，并且a[2]与b[2]指向同一个列表，所以修改a[2][1]会影响b[2][1]

---
##### 关于深拷贝
【一句话介绍】：
深拷贝(Deep Copy)，**递归拷贝顶层对象，以及它内部的子元素对象。**
【换句话说】：深拷贝时，**会拷贝可变元素本身**，而不是地址。

- （1）当顶层对象是mutable可变对象，但是它的子元素对象全都是immutable不可变对象

```
In [1]: a = [1, 'world', 2]

In [2]: import copy

In [3]: b = copy.deepcopy(a)

In [4]: id(a)
Out[4]: 140664823442376

In [5]: id(b)
Out[5]: 140664823349192

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 140664823391544, 9164896]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 140664823391544, 9164896]

In [8]: a[0] = 3

In [9]: a
Out[9]: [3, 'world', 2]

In [10]: b
Out[10]: [1, 'world', 2]

In [11]: [ id(item) for item in a ]
Out[11]: [9164928, 140664823391544, 9164896]

In [12]: [ id(item) for item in b ]
Out[12]: [9164864, 140664823391544, 9164896]
```
【解释】：变量a与变量b指向不同的列表对象，修改a[0]只是将列表a的第一个元素重新指向新对象，不会影响b[0]

---

- （2）当顶层对象是mutable可变对象，但子元素也存在mutable可变对象（子元素部分mutable）

```
In [1]: a = [1, 2, ['hello','world']]

In [2]: import copy

In [3]: b = copy.deepcopy(a)

In [4]: id(a)
Out[4]: 140531593252104

In [5]: id(b)
Out[5]: 140531593479304

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 9164896, 140531593299016]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 9164896, 140531593324232]

In [8]: [ id(item) for item in a[2] ]
Out[8]: [140531582302896, 140531582302784]

In [9]: [ id(item) for item in b[2] ]
Out[9]: [140531582302896, 140531582302784]
```
【解释】：**深拷贝既拷贝了顶层对象，又递归拷贝了子元素对象**，所以a[2]与b[2]指向了两个不同的列表对象(但是列表对象的子元素初始指定的字符串对象一样)，修改a[2][1] = 'china'后，它重新指向了新的字符串对象（内存地址为140531581905808），不会影响到b[2][1]

---

- （3）当顶层对象是immutable不可变对象，同时它的子元素对象也全都是immutable不可变对象

```
In [1]: a = (1, 2, 3)

In [2]: import copy

In [3]: b = copy.deepcopy(a)

In [4]: id(a)
Out[4]: 140021832303960

In [5]: id(b)
Out[5]: 140021832303960

In [6]: [ id(item) for item in a ]
Out[6]: [9164864, 9164896, 9164928]

In [7]: [ id(item) for item in b ]
Out[7]: [9164864, 9164896, 9164928]
```
【嗯，对！】：变量a与变量b指向的是同一个元组对象，不存在拷贝

---

- （4）当顶层对象是immutable不可变对象时，但子元素存在mutable可变对象（子元素部分mutable）
```
In [11]: a
Out[11]: (1, 2, ['hello', 'china'])

In [12]: b
Out[12]: (1, 2, ['hello', 'world'])

In [13]: [ id(item) for item in a[2] ]
Out[13]: [140437024839640, 140437016189336]

In [14]: [ id(item) for item in b[2] ]
Out[14]: [140437024839640, 140437024839528]
```
【不想多打字了...】：变量a与变量b指向的是不同的元组对象，同时a[2]与b[2]指向不同的列表对象，所以修改a[2][1]不会影响b[2][1]

---

#### 其它拷贝方法

（1）列表的复制
列表的复制，有以下三种方式：
   -  列表的copy()函数

   -  list()转换函数
  -   列表分片[:]

```
In [1]: a = [1, 2, ['hello','world']]

In [2]: b = a.copy()

In [3]: c = list(a)

In [4]: d = a[:]

In [5]: id(a), id(b), id(c), id(d)
Out[5]: (140277244933640, 140277244846856, 140277323038536, 140277244767944)

In [6]: a[0] = 100

In [7]: a[2][1] = 'wangy'

In [8]: a
Out[8]: [100, 2, ['hello', 'wangy']]

In [9]: b
Out[9]: [1, 2, ['hello', 'wangy']]

In [10]: c
Out[10]: [1, 2, ['hello', 'wangy']]

In [11]: d
Out[11]: [1, 2, ['hello', 'wangy']]
```
【列表的复制都相当于浅拷贝效果】
【解释】：b/c/d都是a的复制，它们都指向了不同的列表对象，但是没有拷贝子元素，a[2]和b[2]/c[2]/d[2]指向同一个列表，相当于浅拷贝的效果
---

（2）元组的复制
```
In [1]: a = (1, 2, ['hello','world'])

In [2]: b = a[:]

In [3]: id(a), id(b)
Out[3]: (140146192445512, 140146192445512)

In [4]: a
Out[4]: (1, 2, ['hello', 'world'])

In [5]: b
Out[5]: (1, 2, ['hello', 'world'])

In [6]: a[2][1] = 'wangy'

In [7]: a
Out[7]: (1, 2, ['hello', 'wangy'])

In [8]: b
Out[8]: (1, 2, ['hello', 'wangy'])
```
【解释】：使用分片[:]操作，a和b其实是指向同一个元组，而且没有拷贝子元素，a[2]和b[2]也指向同一个列表，相当于`浅拷贝的效果`。

---

（3）字典的复制
```
In [1]: a = {'name': 'wangy', 'age': 18, 'jobs': ['devops', 'dba']}

In [2]: b = a.copy()

In [3]: c = dict(a)

In [4]: id(a), id(b), id(c)
Out[4]: (139653533041504, 139653544192616, 139653533040712)

In [5]: a['age'] = 20

In [6]: a['jobs'].append('python')

In [7]: a
Out[7]: {'name': 'wangy', 'age': 20, 'jobs': ['devops', 'dba', 'python']}

In [8]: b
Out[8]: {'name': 'wangy', 'age': 18, 'jobs': ['devops', 'dba', 'python']}

In [9]: c
Out[9]: {'name': 'wangy', 'age': 18, 'jobs': ['devops', 'dba', 'python']}
```
【解释】：变量a与变量b/c指向不同的字典，但是没有拷贝子元素，a['jobs']和b['jobs']/c['jobs']指定同一个列表，相当于`浅拷贝的效果`

---

（4）集合的复制

同列表类似，可以使用集合的copy()函数或者转换函数set()
```
In [1]: a = {1, 2, 3}

In [2]: b = a.copy()

In [3]: c = set(a)

In [4]: id(a), id(b), id(c)
Out[4]: (139965317888712, 139965317888936, 139965317889608)

In [5]: a.add('wangy')

In [6]: a
Out[6]: {1, 2, 3, 'wangy'}

In [7]: b
Out[7]: {1, 2, 3}

In [8]: c
Out[8]: {1, 2, 3}
```
【解释】：变量a与变量b/c指向不同的集合，而集合的元素必须是hashable，所以修改集合a不会影响到b/c
